# 变量

变量不需要事先声明

    x := 1
    y := 2 + x

数值变更默认是双向的，相比于常见的「过程型」语言，EL是「关系型」语言
相互关联的变量的值都是自动更新的

    x := 1
    y := 2 + x  ;; y => 3
    x := 2      ;; y => 4

EL中的变量存在两个形态：「初始态」和「一般态」



# 赋值

通常意义上的赋值操作在EL中被分为两类：「关系定义」和「值赋予」
当与变量缔结关系的一侧是定值时，该赋值操作为「值赋予」
当缔结关系的一侧是变量或非定值表达式时，该操作为「关系定义」

    x := 1      ;; 关系定义
    y := 2 + x  ;; 关系定义
    x <= 2      ;; 值赋予

值赋予操作是瞬态的，这意味着给与同个变量的不同值的生命周期不可能互相重叠
也就是说变量在某一刻只能持有一个值

    x = 1   ;; x => 1
    x = 2   ;; x => 2

而关系定义则可以多重设置

    x = 1
    x = y - 2   ;; y => 3
    x = z + 1   ;; z => 0
    y = 5       ;; x => 3, z => 2

关系定义在EL中也被分为两类：「固定关系」和「可变关系」
这两者之间的分界并不明显，只是用途不一样而已

如果关系定义被用于描述程序结构，则是「固定关系」
如果是利用关系的变更等操作来传递值，则是「可变关系」

同变量的各个关系之间有优先级区分，用于当值拥有多个来源时的冲突处理
默认是后缔结的关系优先级更高

    x = 1
    y = 2
    z = x   ;; z => 1
    z = y   ;; z => 2, x => 2

在上例中利用优先级来更新x值的操作就是利用关系来传递值
所以z与y的关系就应该被视为「可变关系」

关系的优先级也可以手动设置，使用「分级数值」设置
默认的优先级全部相当于手动的0级

    v = n1
    v = n2
    v =[+9] n3
    v =[++1] n4
    v =[*1-2] n5    ;; * 是 ++ 的简写形式
    
    ;; 优先级顺序为: n4 > n5 > n3 > n2 > n1

关系链中的冲突默认是自动处理的，优先级较高的关系链值会覆盖优先级低的值

    n1 = 1
    n2 = 2
    v =[+1] n1  ;; v = n1 = 1
    v = n2      ;; v = n1 = n2 = 1

但是值赋予操作默认是无视优先级的

    v =[+1] n1
    v = n2
    n1 = 1  ;; v = n1 = n2 = 1
    n2 = 2  ;; v = n1 = n2 = 2

如果需要利用关系的优先级进行比较，但变量的值未准备好，则可以使用undef标记

当一组关系中存在undef时，整个关系的值都是undef，直到所有的undef都被处理完后
关系网才会进行实际的优先级比较和赋值，这么做的意义也是为了保证值的一致性

    n1 = vn1 := undef
    n2 = 2
    v =[+1] n1  ;; v = n1(undef) = undef
    v = n2      ;; v = n1(undef) = n2(2) = undef
    vn1 := 1    ;; v = n1 = n2 = 1

但如果对一个存在undef的关系进行值赋予，则该关系变为已赋值状态
同时所有的undef标记和后续对undef的赋值都被忽略